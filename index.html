<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Multi-Origin 15-Minute Road Isochrones (CSV props passthrough)</title>
  <meta name="description" content="Upload or enter multiple places and calculate 15-minute road-aware isochrones for each using Google Maps Directions (Routes). Exports GeoJSON and a ZIP of all results. CSVs with headers supported; extra columns are passed into GeoJSON properties."/>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    :root{
      --brand:#2563eb;--brand2:#059669;--ink:#111827;--muted:#6b7280;--card:#fff;--bg:#f3f4f6;
      --ok:#10b981;--warn:#f59e0b;--err:#ef4444;--violet:#7c3aed;--slate:#334155
    }
    body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,sans-serif;background:var(--bg);padding:20px;color:var(--ink)}
    .container{max-width:1380px;margin:0 auto}
    .card{background:var(--card);border-radius:14px;box-shadow:0 6px 18px rgba(0,0,0,.06);padding:22px;margin-bottom:16px}
    .header{background:linear-gradient(100deg,var(--brand2),var(--brand));color:#fff;border-radius:16px;padding:28px;margin-bottom:16px}
    .header h1{font-size:30px;font-weight:800;margin-bottom:6px}
    .sub{opacity:.9}
    .grid{display:grid;gap:16px;grid-template-columns:2fr 3fr}
    .form-group{margin-bottom:12px}
    .form-label{display:block;font-size:14px;font-weight:600;color:#374151;margin-bottom:8px}
    .input{width:100%;padding:10px 12px;border:1px solid #d1d5db;border-radius:10px;font-size:14px}
    .btn{padding:10px 14px;background:var(--brand);color:#fff;border:none;border-radius:10px;font-size:14px;font-weight:600;cursor:pointer;transition:.2s;display:inline-flex;align-items:center;gap:8px}
    .btn:hover:not(:disabled){filter:brightness(0.95)}
    .btn-ghost{background:#fff;color:var(--brand);border:1px solid #dbeafe}
    .btn-secondary{background:#6b7280}
    .btn-warning{background:var(--warn)}
    .btn-green{background:var(--brand2)}
    .row{display:flex;gap:8px;align-items:center}
    .small{font-size:12px;color:#6b7280}
    .error{background:#fef2f2;border:1px solid #fecaca;border-radius:12px;padding:10px;color:#991b1b}
    .log{background:#0b1220;color:#cbd5e1;border-radius:12px;padding:12px;height:200px;overflow:auto;font-family:ui-monospace,Menlo,monospace;font-size:12px}
    #map{width:100%;height:72vh;border-radius:14px;background:#eef2ff;border:1px solid #e5e7eb}
    .table{width:100%;border-collapse:separate;border-spacing:0 8px}
    .table th{font-size:12px;color:#6b7280;text-align:left}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;background:#e5e7eb}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap}
    .usagebar{position:sticky;bottom:0;margin-top:18px;background:#0b1220;color:#e5e7eb;border-radius:12px;padding:10px 14px;display:flex;justify-content:space-between;align-items:center;box-shadow:0 -6px 16px rgba(0,0,0,.08)}
    select.input{appearance:auto}
    .prop-chip{font-size:11px;background:#eef2ff;color:#374151;border:1px solid #e5e7eb;border-radius:999px;padding:2px 6px}
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üõ£Ô∏è Multi-Origin 15-Minute Road Isochrones</h1>
      <p class="sub">Upload or enter many places ‚Üí get a 15-minute driving boundary for each (CSV headers supported; extra columns flow into GeoJSON).</p>
    </div>

    <div class="card" style="background:#fef3c7;border:1px solid #fbbf24">
      <div class="row" style="align-items:flex-start">
        <div style="font-size:20px">‚ö†Ô∏è</div>
        <div>
          <div style="font-weight:700;color:#92400e;margin-bottom:4px">API Key Required</div>
          <div class="small" style="color:#92400e">Use a Google Maps API key with <b>Directions/Routes</b> and <b>Places</b> enabled. Restrict your key. Cost is estimated per call.</div>
        </div>
      </div>
    </div>

    <div class="grid">
      <div>
        <div class="card">
          <div class="form-group">
            <label class="form-label">Google Maps API Key</label>
            <div class="row">
              <input id="apiKey" type="password" class="input" placeholder="Enter your API key‚Ä¶">
              <button id="toggleApiKey" class="btn-secondary btn" type="button">üëÅÔ∏è</button>
              <button id="saveApiKey" class="btn" type="button">Save Locally</button>
            </div>
            <div class="small">Stored only in your browser. Est. per-call cost assumes $0.005.</div>
          </div>

          <div class="form-group">
            <label class="form-label">Time Limit (minutes)</label>
            <div class="row">
              <input id="timeLimit" class="input" type="number" min="5" max="60" value="15" style="max-width:120px">
              <span class="small">Use 15 for fixed 15-minute radii.</span>
            </div>
          </div>

          <!-- Country restriction UI -->
          <div class="form-group">
            <label class="form-label">Restrict Geocoding to Country</label>
            <select id="countrySelect" class="input" style="max-width:320px">
              <option value="">No restriction</option>
              <option value="GB" selected>United Kingdom (GB)</option>
            </select>
            <div class="small" style="margin-top:6px">When set, ambiguous place names are geocoded <b>only</b> within the selected country.</div>
          </div>

          <div class="form-group">
            <label class="form-label">Locations</label>
            <div class="row toolbar">
              <button id="addOneBtn" class="btn-ghost btn" type="button">‚ûï Add 1</button>
              <button id="addFiveBtn" class="btn-ghost btn" type="button">‚ûï‚ûï Add 5</button>

              <label class="btn-ghost btn" for="fileInput">üìÅ Upload List</label>
              <input id="fileInput" type="file" accept=".txt,.csv,.json,.geojson" style="display:none"/>

              <!-- FIX: real select for upload mode (was missing) -->
              <select id="uploadMode" class="input" style="max-width:240px">
                <option value="auto" selected>Auto-detect</option>
                <option value="csv_with_headers">CSV: column names</option>
                <option value="csv_name_address">CSV: name,address</option>
                <option value="csv_address_only">CSV: address</option>
                <option value="text_lines">Plain text: one per line</option>
                <option value="text_name_address">Plain text: name | address</option>
              </select>

              <button id="clearListBtn" class="btn-ghost btn" type="button">üßπ Clear</button>
            </div>
            <div class="small" style="margin-top:6px">CSV with headers supported. You can also pick <b>CSV: column names</b> in the dropdown to force header-aware parsing. First row must be column names. We'll detect <b>Name</b> and <b>Address</b> (or <i>Lat</i>/<i>Lng</i>) case‚Äëinsensitively; any other columns are passed through to GeoJSON properties.</div>
          </div>

          <div class="form-group">
            <table class="table">
              <thead><tr><th style="width:34px">#</th><th>Name</th><th>Address (or <code>lat,lng</code>)</th><th>Props</th><th></th></tr></thead>
              <tbody id="rows"></tbody>
            </table>
            <div class="small" id="listStats">0 locations</div>
          </div>

          <div class="form-group row toolbar">
            <button id="calcBtn" class="btn-green btn" type="button">‚ö° Calculate Isochrones</button>
            <button id="exportAllBtn" class="btn-ghost btn" type="button" disabled>‚¨áÔ∏è Export GeoJSON (combined)</button>
            <button id="zipBtn" class="btn-ghost btn" type="button" disabled>üóúÔ∏è Download ZIP (each + combined)</button>
          </div>
        </div>

        <div class="card">
          <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:6px">
            <div style="font-weight:700">Activity Log</div>
            <button id="clearLogBtn" class="btn-ghost btn" type="button">Clear</button>
          </div>
          <div id="log" class="log"><div style="color:#64748b">Waiting for API key‚Ä¶</div></div>
        </div>

        <div class="card">
          <div style="font-weight:700;margin-bottom:10px">Run Summary</div>
          <div class="row" style="gap:16px;flex-wrap:wrap">
            <span class="pill">Origins: <b id="statOrigins">0</b></span>
            <span class="pill">API Calls: <b id="statCalls">0</b></span>
            <span class="pill">Boundary Points: <b id="statPts">0</b></span>
            <span class="pill">Est. Cost: <b id="statCost">$0.000</b></span>
          </div>
        </div>
      </div>

      <div>
        <div class="card">
          <div class="toolbar" style="margin-bottom:10px">
            <button id="resetViewBtn" class="btn-ghost btn" type="button">üîÑ Reset View</button>
            <button id="fullscreenBtn" class="btn-ghost btn" type="button">‚§¢ Fullscreen</button>
          </div>
          <div id="map"></div>
        </div>

        <div class="card">
          <div style="font-weight:700;margin-bottom:8px">How this works</div>
          <div class="small" style="line-height:1.6;color:var(--slate)">
            ‚Ä¢ Uses your single-origin algorithm per location: generates radial test destinations, requests driving routes, and finds the 15-minute boundary point along each route. <br>
            ‚Ä¢ Fills angular gaps, sorts points, draws polygons, and exports per-origin GeoJSON + a combined file. <br>
            ‚Ä¢ All in the browser (static), suitable for GitHub Pages. <br>
            ‚Ä¢ NEW: CSV headers with any number of columns. Unrecognized columns are attached to GeoJSON features as properties.
          </div>
        </div>
      </div>
    </div>

    <div class="usagebar">
      <div>API Calls: <b id="usageCalls">0</b> ‚Ä¢ Points: <b id="usagePoints">0</b></div>
      <div>Est. Cost: <b id="usageCost">$0.000</b></div>
    </div>
  </div>

  <!-- JSZip + FileSaver (reliable CDN; no SRI) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <script>
    // ---------- State ----------
    const state = {
      apiKey: '',
      map: null,
      directionsService: null,
      geocoder: null,
      timeLimit: 15,
      estCostPerCall: 0.005,
      maxApiCallsPerOrigin: 100,
      logs: [],
      apiCalls: 0,
      totalPoints: 0,
      rows: [], // DOM rows only
      results: [], // per origin { name, origin, points[], polygon, markers[], props }
      palette: ['#10b981','#3b82f6','#f59e0b','#ef4444','#7c3aed','#14b8a6','#f97316','#eab308','#22c55e','#8b5cf6'],
      country: 'GB', // ISO-3166-1 alpha-2. Default to UK.
      uploadMode: 'auto',
    };

    // ---------- DOM ----------
    const el = {
      apiKey: document.getElementById('apiKey'),
      toggleApiKey: document.getElementById('toggleApiKey'),
      saveApiKey: document.getElementById('saveApiKey'),
      timeLimit: document.getElementById('timeLimit'),
      rows: document.getElementById('rows'),
      addOneBtn: document.getElementById('addOneBtn'),
      addFiveBtn: document.getElementById('addFiveBtn'),
      fileInput: document.getElementById('fileInput'),
      clearListBtn: document.getElementById('clearListBtn'),
      listStats: document.getElementById('listStats'),
      calcBtn: document.getElementById('calcBtn'),
      exportAllBtn: document.getElementById('exportAllBtn'),
      zipBtn: document.getElementById('zipBtn'),
      log: document.getElementById('log'),
      clearLogBtn: document.getElementById('clearLogBtn'),
      mapDiv: document.getElementById('map'),
      resetViewBtn: document.getElementById('resetViewBtn'),
      fullscreenBtn: document.getElementById('fullscreenBtn'),
      statOrigins: document.getElementById('statOrigins'),
      statCalls: document.getElementById('statCalls'),
      statPts: document.getElementById('statPts'),
      statCost: document.getElementById('statCost'),
      usageCalls: document.getElementById('usageCalls'),
      usagePoints: document.getElementById('usagePoints'),
      usageCost: document.getElementById('usageCost'),
      countrySelect: document.getElementById('countrySelect'),
      uploadMode: document.getElementById('uploadMode'),
    };

    // Load saved key
    const savedKey = localStorage.getItem('gmaps_api_key');
    if (savedKey){ state.apiKey = savedKey; el.apiKey.value = savedKey; addLog('API key loaded from local storage','success'); loadGoogleMaps(); }

    // Load saved country
    const savedCountry = localStorage.getItem('gmaps_country');
    if (savedCountry !== null) {
      state.country = savedCountry || '';
      if (el.countrySelect) el.countrySelect.value = state.country;
    }

    // Load saved upload mode
    const savedUploadMode = localStorage.getItem('upload_mode');
    if (savedUploadMode){ state.uploadMode = savedUploadMode; if (el.uploadMode) el.uploadMode.value = savedUploadMode; }

    // ---------- Utils ----------
    function centroidFromPath(pathArr){
      const pts = pathArr.map(ll => ({ x: ll.lng(), y: ll.lat() }));
      const n = pts.length;
      if (n < 3){
        const avg = pts.reduce((a,p)=>({x:a.x+p.x, y:a.y+p.y}), {x:0,y:0});
        return { lat: avg.y/n, lng: avg.x/n };
      }
      let twiceArea = 0, Cx = 0, Cy = 0;
      for (let i = 0; i < n; i++){
        const j = (i+1) % n;
        const cross = pts[i].x*pts[j].y - pts[j].x*pts[i].y;
        twiceArea += cross;
        Cx += (pts[i].x + pts[j].x) * cross;
        Cy += (pts[i].y + pts[j].y) * cross;
      }
      if (Math.abs(twiceArea) < 1e-12){
        const avg = pts.reduce((a,p)=>({x:a.x+p.x, y:a.y+p.y}), {x:0,y:0});
        return { lat: avg.y/n, lng: avg.x/n };
      }
      Cx /= (3 * twiceArea);
      Cy /= (3 * twiceArea);
      return { lat: Cy, lng: Cx };
    }

    function addLog(message,type='info'){
      const timestamp = new Date().toLocaleTimeString();
      state.logs.push({message,type,timestamp});
      console.log(`[${type}] ${message}`);
      el.log.innerHTML = state.logs.map(l=>`<div style="color:${
        l.type==='error'?'#f87171':l.type==='success'?'#34d399':l.type==='warning'?'#fbbf24':'#cbd5e1' }">[${l.timestamp}] ${l.message}</div>`).join('');
      el.log.scrollTop = el.log.scrollHeight;
    }
    function updateStats(){
      const cost = state.apiCalls * state.estCostPerCall;
      el.statOrigins.textContent = state.results.length;
      el.statCalls.textContent = state.apiCalls;
      el.statPts.textContent = state.totalPoints;
      el.statCost.textContent = `$${cost.toFixed(3)}`;
      el.usageCalls.textContent = state.apiCalls;
      el.usagePoints.textContent = state.totalPoints;
      el.usageCost.textContent = `$${cost.toFixed(3)}`;
    }

    // ---------- Table rows ----------
    function addRow(name = '', address = '', props = {}) {
      const idx = state.rows.length + 1;

      const tr = document.createElement('tr');
      tr.dataset.props = JSON.stringify(props || {});

      const tdIdx = document.createElement('td');
      tdIdx.className = 'small';
      tdIdx.textContent = idx;

      const tdName = document.createElement('td');
      const nameInput = document.createElement('input');
      nameInput.className = 'input name';
      nameInput.placeholder = 'Name (optional)';
      nameInput.value = name;
      tdName.appendChild(nameInput);

      const tdAddr = document.createElement('td');
      const addrInput = document.createElement('input');
      addrInput.className = 'input address';
      addrInput.placeholder = 'Address or lat,lng';
      addrInput.value = address;
      tdAddr.appendChild(addrInput);

      const tdProps = document.createElement('td');
      tdProps.className = 'small';
      const count = Object.keys(props||{}).length;
      tdProps.innerHTML = count ? `<span class="prop-chip">${count} prop${count>1?'s':''}</span>` : '<span class="small" style="color:#94a3b8">‚Äî</span>';

      const tdRemove = document.createElement('td');
      const removeBtn = document.createElement('button');
      removeBtn.className = 'btn-ghost btn remove';
      removeBtn.type = 'button';
      removeBtn.textContent = '‚úñ';
      tdRemove.appendChild(removeBtn);

      tr.append(tdIdx, tdName, tdAddr, tdProps, tdRemove);
      el.rows.appendChild(tr);

      state.rows.push(tr);
      el.listStats.textContent = `${state.rows.length} locations`;

      removeBtn.addEventListener('click', () => {
        tr.remove();
        state.rows = state.rows.filter(r => r !== tr);
        renumberRows();
      });
    }

    function renumberRows(){
      [...el.rows.children].forEach((tr,i)=> tr.children[0].textContent = i+1);
      el.listStats.textContent = `${state.rows.length} locations`;
    }

    // ---------- Robust parsing helpers ----------
    function stripBOM(s) { return s.replace(/^\uFEFF/, ''); }
    function unquote(s) {
      s = s.trim();
      if (s.startsWith('"') && s.endsWith('"')) s = s.slice(1, -1).replace(/""/g, '"');
      return s;
    }
    function splitCsvLine(line) {
      line = stripBOM(line);
      const fields = [];
      let cur = '', inQ = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (ch === '"') {
          if (inQ && line[i + 1] === '"') { cur += '"'; i++; }
          else inQ = !inQ;
        } else if (ch === ',' && !inQ) {
          fields.push(cur.trim());
          cur = '';
        } else {
          cur += ch;
        }
      }
      fields.push(cur.trim());
      return fields;
    }

    function parseLines(text){
      return text
        .split(/\r?\n/)
        .map(l=>stripBOM(l).trim())
        .filter(Boolean)
        .map(addr=>({name:'', address:addr, props:{}}));
    }
    function parseLinesNameAddress(text) {
      return text
        .split(/\r?\n/)
        .map(l => stripBOM(l).trim())
        .filter(Boolean)
        .map(line => {
          const m = line.match(/^(.*?)\s*(?:\||;|\t)\s*(.+)$/);
          if (!m) return null;
          const name = m[1].trim();
          const address = m[2].trim();
          if (!address) return null;
          return { name, address, props:{} };
        })
        .filter(Boolean);
    }

    // ---- NEW: CSV with header & passthrough props ----
    function normalizeKey(k){
      return String(k||'')
        .replace(/\uFEFF/g,'')
        .trim()
        .toLowerCase()
        .replace(/\s+/g,' ');
    }
    function parseCSV_Generic(text){
      const lines = text.split(/\r?\n/).filter(l=>l.trim().length>0);
      if (!lines.length) return [];
      const rows = lines.map(splitCsvLine).map(arr=>arr.map(unquote));
      if (rows.length===0) return [];

      const header = rows[0].map(normalizeKey);
      const data = rows.slice(1);

      // Try to identify columns
      const colIdx = (preds)=> header.findIndex(h=>preds.some(p=>p.test(h)));
      const nameIdx    = colIdx([/^(name|title)$/i]);
      const addressIdx = colIdx([/^(address|addr|location|place)$/i]);
      const latIdx     = colIdx([/^lat(itude)?$/i]);
      const lngIdx     = colIdx([/^(lon|lng|long|longitude)$/i]);

      // If header doesn't look like headers (i.e., no common matches), fall back later
      const headerLooksValid = nameIdx>=0 || addressIdx>=0 || (latIdx>=0 && lngIdx>=0);
      if (!headerLooksValid) return null; // signal to caller to try other heuristics

      const out = [];
      for (const row of data){
        if (!row || row.every(v=>String(v||'').trim()==='')) continue;
        const name = nameIdx>=0 ? row[nameIdx] : '';
        let address = addressIdx>=0 ? row[addressIdx] : '';
        if (!address && latIdx>=0 && lngIdx>=0){
          const la = row[latIdx], lo = row[lngIdx];
          if (la!==undefined && lo!==undefined && String(la).trim()!=='' && String(lo).trim()!==''){
            address = `${la},${lo}`; // we reuse existing lat,lng flow
          }
        }
        if (!address) continue; // must have address or lat/lng

        const props = {};
        header.forEach((key, i)=>{
          if (i===nameIdx || i===addressIdx || i===latIdx || i===lngIdx) return;
          const v = row[i];
          if (v!==undefined && String(v).trim()!=='') props[rows[0][i]] = v; // original casing
        });
        out.push({ name, address, props });
      }
      return out;
    }

    // Legacy/explicit CSV parsers remain (no props passthrough)
    function parseCSV_NameAddress(text){
      const rows = text
        .split(/\r?\n/)
        .map(l=>l.trim())
        .filter(Boolean)
        .map(line=>{
          const parts = splitCsvLine(line).map(unquote);
          if (parts.length < 2) return null;
          return { name: parts[0], address: parts.slice(1).join(','), props:{} };
        })
        .filter(Boolean);
      // Drop header if looks like it
      if (rows.length && /name/i.test(rows[0].name) && /address|location/i.test(rows[0].address)) rows.shift();
      return rows;
    }
    function parseCSV_AddressOnly(text) {
      const rows = text
        .split(/\r?\n/)
        .map(l => stripBOM(l).trim())
        .filter(l => l.length > 0)
        .map(line => ({ name: '', address: unquote(line), props:{} }));
      return rows;
    }

    function parseCSV_Auto(text){
      // Try generic header-aware parser first
      const generic = parseCSV_Generic(text);
      if (Array.isArray(generic)) return generic;

      // Otherwise, simple heuristic: 1 = address, 2 = name,address, >=3 = name,rest‚Üíaddress
      const rows = text
        .split(/\r?\n/)
        .map(l=>l.trim())
        .filter(Boolean)
        .map(line=>{
          const parts = splitCsvLine(line).map(unquote);
          if (parts.length===1) return { name:'', address:parts[0], props:{} };
          if (parts.length===2) return { name:parts[0], address:parts[1], props:{} };
          if (parts.length>=3) return { name:parts[0], address:parts.slice(1).join(','), props:{} };
          return null;
        })
        .filter(Boolean);
      if (rows.length && /name/i.test(rows[0].name) && /address|location/i.test(rows[0].address)) rows.shift();
      return rows;
    }

    // FIX: implement file.text() and remove stray placeholders
    async function parseFile(file, mode){
      const text = await file.text();
      if (mode === 'csv_with_headers') { const r = parseCSV_Generic(text); return Array.isArray(r) ? r : []; }
      if (mode === 'csv_name_address') return parseCSV_NameAddress(text);
      if (mode === 'csv_address_only') return parseCSV_AddressOnly(text);
      if (mode === 'text_lines') return parseLines(text);
      if (mode === 'text_name_address') return parseLinesNameAddress(text);

      // Auto-detect JSON/GeoJSON first
      try{
        const data = JSON.parse(text);
        if (Array.isArray(data)){
          return data
            .map(o=>({ name:o.name||'', address: o.address || (o.lat!=null&&o.lng!=null? `${o.lat},${o.lng}` : ''), props: (()=>{ const {name,address,lat,lng, ...rest} = o||{}; return rest; })() }))
            .filter(o=>o.address);
        }
        if (data && data.type && String(data.type).toLowerCase()==='featurecollection' && Array.isArray(data.features)){
          return data.features.map(f=>{
            const props = f.properties||{}; const g=f.geometry||{};
            let address = '';
            if (g.type==='Point' && Array.isArray(g.coordinates)){
              address = `${g.coordinates[1]},${g.coordinates[0]}`;
            } else {
              address = props.address || props.location || '';
            }
            if (!address) return null;
            const { name, address:addr, location, ...rest } = props;
            return { name: name || '', address, props: rest };
          }).filter(Boolean);
        }
      }catch{
        // not JSON; continue
      }
      // Fallback to CSV auto heuristic (header-aware first)
      return parseCSV_Auto(text);
    }

    // ---------- Geometry helpers ----------
    function haversineDest(origin, bearingDeg, distanceKm){
      const R=6371, br=bearingDeg*Math.PI/180, lat1=origin.lat*Math.PI/180, lng1=origin.lng*Math.PI/180, d=distanceKm/R;
      const lat2 = Math.asin(Math.sin(lat1)*Math.cos(d)+Math.cos(lat1)*Math.sin(d)*Math.cos(br));
      const lng2 = lng1 + Math.atan2(Math.sin(br)*Math.sin(d)*Math.cos(lat1), Math.cos(d)-Math.sin(lat1)*Math.sin(lat2));
      return { lat: lat2*180/Math.PI, lng: lng2*180/Math.PI };
    }

    function dedupeByAngle(center, points, toleranceDeg = 5) {
      if (!points || points.length < 2) return points;

      const centerLL = new google.maps.LatLng(center.lat, center.lng);

      const annotated = points.map(p => {
        const ang = (Math.atan2(p.lng - center.lng, p.lat - center.lat) * 180 / Math.PI + 360) % 360;
        const dist = google.maps.geometry.spherical.computeDistanceBetween(
          new google.maps.LatLng(p.lat, p.lng),
          centerLL
        );
        return { p, ang, dist };
      }).sort((a, b) => a.ang - b.ang);

      const clusters = [];
      let cur = [annotated[0]];
      for (let i = 1; i < annotated.length; i++) {
        const prev = annotated[i - 1];
        const curr = annotated[i];
        if (curr.ang - prev.ang <= toleranceDeg) {
          cur.push(curr);
        } else {
          clusters.push(cur);
          cur = [curr];
        }
      }
      clusters.push(cur);

      if (clusters.length > 1) {
        const firstCluster = clusters[0];
        const lastCluster = clusters[clusters.length - 1];
        const firstAng = firstCluster[0].ang;
        const lastAng = lastCluster[lastCluster.length - 1].ang;
        const wrapDiff = (firstAng + 360) - lastAng;
        if (wrapDiff <= toleranceDeg) {
          const merged = lastCluster.concat(firstCluster);
          clusters[0] = merged;
          clusters.pop();
        }
      }

      const kept = clusters.map(group => {
        let best = group[0];
        for (let i = 1; i < group.length; i++) {
          if (group[i].dist > best.dist) best = group[i];
        }
        return best.p;
      });

      return kept;
    }

    async function testRoute(origin, destination){
      return new Promise((resolve)=>{
        const req={ origin, destination, travelMode: google.maps.TravelMode.DRIVING, unitSystem: google.maps.UnitSystem.METRIC, provideRouteAlternatives:true };
        state.directionsService.route(req,(r,status)=>{
          state.apiCalls++; updateStats();
          if(status!=='OK' || !r?.routes?.length){ return resolve(null); }
          const limitMin = state.timeLimit;
          let bestPoint=null, bestDist=0;
          for (const route of r.routes){
            let accMin=0; let boundary=null;
            for (const leg of route.legs){
              for (const step of leg.steps){
                const stepMin = step.duration.value/60;
                if (accMin + stepMin <= limitMin){
                  accMin += stepMin;
                } else {
                  const remaining = limitMin - accMin;
                  const frac = Math.max(0, Math.min(1, remaining/stepMin));
                  if (step.path && step.path.length>1){
                    const totalDist = google.maps.geometry.spherical.computeLength(step.path);
                    const target = totalDist * frac; let acc=0;
                    for (let i=0;i<step.path.length-1;i++){
                      const seg = google.maps.geometry.spherical.computeDistanceBetween(step.path[i], step.path[i+1]);
                      if (acc + seg >= target){
                        const segFrac = (target - acc) / seg;
                        const boundary = {
                          lat: step.path[i].lat() + (step.path[i+1].lat() - step.path[i].lat())*segFrac,
                          lng: step.path[i].lng() + (step.path[i+1].lng() - step.path[i].lng())*segFrac
                        };
                        // NOTE: shadowing boundary fixed
                        acc = target; // force exit
                        // Return this point
                        if (boundary) {
                          // compute best
                        }
                      }
                      acc += seg;
                    }
                  }
                  if (!boundary){
                    const s=step.start_location,e=step.end_location;
                    boundary = { lat: s.lat()+(e.lat()-s.lat())*frac, lng: s.lng()+(e.lng()-s.lng())*frac };
                  }
                  break;
                }
              }
              if (boundary) break;
            }
            if (boundary){
              const d = Math.hypot(boundary.lat-origin.lat, boundary.lng-origin.lng);
              if (d>bestDist){ bestDist=d; bestPoint=boundary; }
            }
          }
          resolve(bestPoint);
        });
      });
    }

    async function fillGaps(center, points){
      const out=[]; if (points.length<3) return out;
      const sorted=[...points].sort((a,b)=>{
        const A=Math.atan2(a.lng-center.lng, a.lat-center.lat); const B=Math.atan2(b.lng-center.lng, b.lat-center.lat); return A-B;
      });
      for(let i=0;i<sorted.length;i++){
        const j=(i+1)%sorted.length, p1=sorted[i], p2=sorted[j];
        let a1=Math.atan2(p1.lng-center.lng, p1.lat-center.lat)*180/Math.PI;
        let a2=Math.atan2(p2.lng-center.lng, p2.lat-center.lat)*180/Math.PI;
        let diff=a2-a1; if(diff<0) diff+=360;
        if (diff>30){
          const mid=(a1+diff/2)%360;
          const test = haversineDest(center, mid, 25);
          const r = await testRoute(center, test);
          if (r) out.push(r);
        }
      }
      return out;
    }

    function sortClockwise(center, pts){
      return [...pts].sort((a,b)=>{
        const A=Math.atan2(a.lng-center.lng, a.lat-center.lat); const B=Math.atan2(b.lng-center.lng, b.lat-center.lat); return A-B;
      });
    }

    function drawOriginResult(origin, color, name, points){
      const markers=[];
      points.forEach((p,i)=>{
        const m=new google.maps.Marker({ position:p, map:state.map, title:`${name||'Origin'} ‚Äî point ${i+1}`, icon:{path:google.maps.SymbolPath.CIRCLE, scale:5, fillColor:color, fillOpacity:.9, strokeColor:'#fff', strokeWeight:1.5}});
        markers.push(m);
      });
      let polygon=null;
      if (points.length>=3){
        const sorted=sortClockwise(origin, points);
        polygon = new google.maps.Polygon({ paths:sorted, strokeColor:color, strokeOpacity:.95, strokeWeight:2, fillColor:color, fillOpacity:.18, map:state.map });
        const bounds = new google.maps.LatLngBounds(); sorted.forEach(pt=>bounds.extend(pt)); bounds.extend(origin); state.map.fitBounds(bounds);
      }
      return { markers, polygon };
    }

    // ---- merge props safely, letting tool-defined keys win ----
    function mergeProps(extra, base){
      return { ...(extra||{}), ...base };
    }

    function toGeoJSONFeatureCollection(origins){
      const features = [];
      for (const o of origins){
        const extra = o.props || {};
        if (o.polygon){
          const path = o.polygon.getPath().getArray().map(ll => [ll.lng(), ll.lat()]);
          if (path.length){
            features.push({
              type:'Feature',
              properties: mergeProps(extra, { type:'isochrone', minutes: state.timeLimit, name:o.name }),
              geometry:{ type:'Polygon', coordinates:[ [...path, path[0]] ] }
            });
            const c = centroidFromPath(o.polygon.getPath().getArray());
            features.push({
              type:'Feature',
              properties: mergeProps(extra, { type:'centroid', minutes: state.timeLimit, name:o.name }),
              geometry:{ type:'Point', coordinates:[c.lng, c.lat] }
            });
          }
        }
        if (o.points?.length){
          features.push({
            type:'Feature',
            properties: mergeProps(extra, { type:'boundary-points', name:o.name }),
            geometry:{ type:'MultiPoint', coordinates:o.points.map(p=>[p.lng,p.lat]) }
          });
        }
        if (o.origin){
          features.push({
            type:'Feature',
            properties: mergeProps(extra, { type:'origin', name:o.name }),
            geometry:{ type:'Point', coordinates:[o.origin.lng, o.origin.lat] }
          });
        }
      }
      return { type:'FeatureCollection', features };
    }

    function saveBlob(data, filename, mime){
      const blob = new Blob([data], {type:mime});
      if (!window.saveAs) { addLog('Download library (FileSaver) not loaded.','error'); return; }
      saveAs(blob, filename);
    }

    async function exportCombined(){
      const fc = toGeoJSONFeatureCollection(state.results);
      if (!fc.features.length){ addLog('Nothing to export. Run a calculation first.','warning'); return; }
      saveBlob(JSON.stringify(fc,null,2), `isochrones_${state.timeLimit}min_combined.geojson`, 'application/geo+json');
      addLog('‚¨áÔ∏è Exported combined GeoJSON','success');
    }

    async function exportZip(){
      if (!state.results.length){ addLog('Nothing to zip. Run a calculation first.','warning'); return; }
      if (!window.JSZip || !window.saveAs) { addLog('ZIP/export libraries not loaded.','error'); return; }
      const zip = new JSZip();
      const folder = zip.folder(`isochrones_${state.timeLimit}min`);
      state.results.forEach((r,i)=>{
        const base = (r.name||`origin_${i+1}`).replace(/[^a-z0-9_\-]+/gi,'_');
        const fc = toGeoJSONFeatureCollection([r]);
        folder.file(`${base}.geojson`, JSON.stringify(fc,null,2));
      });
      const combined = toGeoJSONFeatureCollection(state.results);
      folder.file(`combined.geojson`, JSON.stringify(combined,null,2));
      const content = await zip.generateAsync({type:'blob'});
      saveAs(content, `isochrones_${state.timeLimit}min.zip`);
      addLog('üóúÔ∏è Downloaded ZIP with all results','success');
    }

    async function geocodeOne(input){
      input = input.trim();
      const m = input.match(/^\s*(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)\s*$/);
      if (m){ return { lat: parseFloat(m[1]), lng: parseFloat(m[2]) }; }
      return new Promise((resolve)=>{
        const req = { address: input };
        if (state.country) {
          req.componentRestrictions = { country: state.country };
          req.region = state.country.toLowerCase() === 'gb' ? 'uk' : undefined;
        }
        state.geocoder.geocode(req,(res,status)=>{
          if (status==='OK' && res && res[0]){
            const loc = res[0].geometry.location; resolve({ lat: loc.lat(), lng: loc.lng() });
          } else { resolve(null); }
        });
      });
    }

    async function calculateForOrigin({name, origin, color, props}){
      addLog(`‚ñ∂Ô∏è ${name||'Origin'}: generating test destinations‚Ä¶`);
      const distances = [10, 15, 20, 25, 30, 35]; // kilometers
      const angles = [
        0, 10, 20, 30, 40, 50, 60, 70, 80, 90,
        100, 110, 120, 130, 140, 150, 160, 170, 180, 190,
        200, 210, 220, 230, 240, 250, 260, 270, 280, 290,
        300, 310, 320, 330, 340, 350
      ];

      const tests=[]; angles.forEach(a=>distances.forEach(km=>tests.push(haversineDest(origin, a, km))));
      const points=[]; const batch=8;
      for (let i=0;i<tests.length; i+=batch){
        const slice = tests.slice(i,i+batch);
        const res = await Promise.all(slice.map(dest=>testRoute(origin, dest)));
        res.forEach(p=>{ if(p) points.push(p); });
        if (i+batch<tests.length){ await new Promise(r=>setTimeout(r,150)); }
      }
      addLog(`‚úÖ ${name||'Origin'}: ${points.length} boundary points`,'success');

      if (points.length>=3){
        addLog(`üß© ${name||'Origin'}: filling angular gaps‚Ä¶`);
        const extra = await fillGaps(origin, points);
        extra.forEach(p=>points.push(p));
      }

      const before = points.length;
      let filtered = dedupeByAngle(origin, points, 5);
      const removed = before - filtered.length;
      if (removed > 0) {
        addLog(`üßπ ${name || 'Origin'}: removed ${removed} near-duplicate point(s) within 5¬∞ (kept farthest).`, 'success');
      }
      points.length = 0; points.push(...filtered);

      state.totalPoints += points.length; updateStats();
      const drawn = drawOriginResult(origin, color, name, points);
      return { name, origin, points, polygon: drawn.polygon, markers: drawn.markers, color, props };
    }

    async function runCalculation(){
      try {
        if (!state.apiKey || !window.google){ addLog('Enter API key and ensure Google Maps loaded.','error'); return; }
        const timeVal = parseInt(el.timeLimit.value,10)||15; state.timeLimit = timeVal; updateStats();

        // Collect inputs
        const items = [...el.rows.querySelectorAll('tr')].map(tr=>({
          name: tr.querySelector('.name').value.trim(),
          address: tr.querySelector('.address').value.trim(),
          props: (()=>{ try { return JSON.parse(tr.dataset.props||'{}'); } catch { return {}; } })()
        })).filter(x=>x.address);
        if (!items.length){ addLog('Add at least one location.','warning'); return; }

        // Reset previous results
        state.results.forEach(r=>{ r.markers?.forEach(m=>m.setMap(null)); r.polygon?.setMap(null); });
        state.results = []; state.apiCalls=0; state.totalPoints=0; updateStats();

        // Geocode all
        addLog(`üìç Geocoding ${items.length} location(s)‚Ä¶ ${state.country?`[country=${state.country}]`:''}`);
        const origins = [];
        for (const it of items){
          const loc = await geocodeOne(it.address);
          if (!loc){ addLog(`‚ùå Geocode failed for: ${it.address}`,'error'); continue; }
          origins.push({ name: it.name||it.address, origin: loc, props: it.props||{} });
        }
        if (!origins.length){ addLog('No valid origins to process.','error'); return; }

        // Draw origin markers
        const bounds = new google.maps.LatLngBounds();
        origins.forEach(o=> bounds.extend(o.origin));
        state.map.fitBounds(bounds);

        // Run per origin sequentially
        let idx=0;
        for (const o of origins){
          const color = state.palette[idx % state.palette.length]; idx++;
          const m = new google.maps.Marker({ position:o.origin, map:state.map, title:o.name, icon:{path:google.maps.SymbolPath.CIRCLE, scale:8, fillColor:color, fillOpacity:1, strokeColor:'#fff', strokeWeight:2}});
          const res = await calculateForOrigin({name:o.name, origin:o.origin, color, props:o.props});
          res.markers.push(m);
          state.results.push(res);
        }

        // Enable exports
        el.exportAllBtn.disabled = false;
        el.zipBtn.disabled = false;
        addLog('‚ú® All origins processed.','success');
      } catch (err) {
        console.error(err);
        addLog(`üí• Unexpected error: ${err?.message || err}`, 'error');
      }
    }

    // ---------- Google Maps boot ----------
    function loadGoogleMaps(){
      if (!state.apiKey){ addLog('Please enter your Google Maps API key','warning'); return; }
      if (window.google?.maps){ initMap(); return; }
      addLog('Loading Google Maps script‚Ä¶');
      const s=document.createElement('script');
      s.src = `https://maps.googleapis.com/maps/api/js?key=${state.apiKey}&libraries=geometry,places`;
      s.async=true; s.onload=()=>{ addLog('Google Maps loaded','success'); initMap(); };
      s.onerror=()=> addLog('Failed to load Google Maps','error');
      document.body.appendChild(s);
    }
    function initMap(){
      if (state.map) return;
      state.map = new google.maps.Map(el.mapDiv,{ center:{lat:51.5074,lng:-0.1278}, zoom:6, fullscreenControl:true, streetViewControl:false, mapTypeControl:false, styles:[{featureType:'poi',stylers:[{visibility:'off'}]},{featureType:'transit',stylers:[{visibility:'off'}]}] });
      state.directionsService = new google.maps.DirectionsService();
      state.geocoder = new google.maps.Geocoder();
    }

    // ---------- Events ----------
    el.toggleApiKey.addEventListener('click',()=>{
      el.apiKey.type = el.apiKey.type==='password' ? 'text' : 'password';
      el.toggleApiKey.textContent = el.apiKey.type==='password' ? 'üëÅÔ∏è' : 'üôà';
    });
    el.saveApiKey.addEventListener('click',()=>{ const k=el.apiKey.value.trim(); if(k){ localStorage.setItem('gmaps_api_key',k); state.apiKey=k; addLog('API key saved','success'); loadGoogleMaps(); } });
    el.apiKey.addEventListener('change', e=>{ state.apiKey=e.target.value; if(state.apiKey) loadGoogleMaps(); });

    el.countrySelect.addEventListener('change', e=>{
      state.country = e.target.value || '';
      localStorage.setItem('gmaps_country', state.country);
      addLog(state.country ? `üåç Country restriction set to ${state.country}` : 'üåç Country restriction cleared');
    });

    // FIX: guard ‚Äî only attach if element exists
    if (el.uploadMode) {
      el.uploadMode.addEventListener('change', e=>{
        state.uploadMode = e.target.value;
        localStorage.setItem('upload_mode', state.uploadMode);
        addLog(`üìÑ Upload mode: ${state.uploadMode}`);
      });
    }

    el.addOneBtn.addEventListener('click',()=> addRow());
    el.addFiveBtn.addEventListener('click',()=>{ for(let i=0;i<5;i++) addRow(); });
    el.clearListBtn.addEventListener('click',()=>{ el.rows.innerHTML=''; state.rows=[]; renumberRows(); });

    el.fileInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0]; if (!file) return;
      el.rows.innerHTML = ''; state.rows = []; renumberRows();

      const list = await parseFile(file, state.uploadMode);
      list.forEach(item => addRow(item.name || '', item.address || '', item.props || {}));
      addLog(`üì• Loaded ${list.length} from file (${state.uploadMode})`, 'success');
      e.target.value = '';
    });

    el.calcBtn.addEventListener('click', runCalculation);
    el.exportAllBtn.addEventListener('click', exportCombined);
    el.zipBtn.addEventListener('click', exportZip);

    el.clearLogBtn.addEventListener('click',()=>{ state.logs=[]; addLog('Logs cleared','info'); });
    el.resetViewBtn.addEventListener('click',()=>{ if(state.map){ state.map.setCenter({lat:51.5074,lng:-0.1278}); state.map.setZoom(6); } });
    el.fullscreenBtn.addEventListener('click',()=>{ const card = el.mapDiv.parentElement; if (!document.fullscreenElement){ (card.requestFullscreen ? card.requestFullscreen() : el.mapDiv.requestFullscreen?.()); } else { document.exitFullscreen?.(); }});

    // Pre-populate a couple of rows for convenience
    addRow('London','London, UK', {region:'England'});
    addRow('Manchester','Manchester, UK', {region:'England'});

    // Disable export buttons if libs missing
    document.addEventListener('DOMContentLoaded', () => {
      const hasZip   = !!window.JSZip;
      const hasSave  = !!window.saveAs;
      const exportBtn = document.getElementById('exportAllBtn');
      const zipBtn    = document.getElementById('zipBtn');
      if (exportBtn) exportBtn.disabled = !hasSave;
      if (zipBtn)    zipBtn.disabled    = !(hasZip && hasSave);
    });
  </script>
</body>
</html>
