function dedupeByAngle(center, points, toleranceDeg = 5) {
  if (!points || points.length < 2) return points;

  const centerLL = new google.maps.LatLng(center.lat, center.lng);

  // Annotate each point with its angle [0,360) and distance from center
  const annotated = points.map(p => {
    const ang = (Math.atan2(p.lng - center.lng, p.lat - center.lat) * 180 / Math.PI + 360) % 360;
    const dist = google.maps.geometry.spherical.computeDistanceBetween(
      new google.maps.LatLng(p.lat, p.lng),
      centerLL
    );
    return { p, ang, dist };
  }).sort((a, b) => a.ang - b.ang);

  // Build clusters of points within tolerance by sweeping sorted angles
  const clusters = [];
  let cur = [annotated[0]];
  for (let i = 1; i < annotated.length; i++) {
    const prev = annotated[i - 1];
    const curr = annotated[i];
    if (curr.ang - prev.ang <= toleranceDeg) {
      cur.push(curr);
    } else {
      clusters.push(cur);
      cur = [curr];
    }
  }
  clusters.push(cur);

  // Handle wrap-around (last cluster and first cluster may be within tolerance)
  if (clusters.length > 1) {
    const firstCluster = clusters[0];
    const lastCluster = clusters[clusters.length - 1];
    const firstAng = firstCluster[0].ang;
    const lastAng = lastCluster[lastCluster.length - 1].ang;
    const wrapDiff = (firstAng + 360) - lastAng;
    if (wrapDiff <= toleranceDeg) {
      // Merge: keep order as last + first
      const merged = lastCluster.concat(firstCluster);
      clusters[0] = merged;
      clusters.pop();
    }
  }

  // From each cluster, keep the farthest point from the center
  const kept = clusters.map(group => {
    let best = group[0];
    for (let i = 1; i < group.length; i++) {
      if (group[i].dist > best.dist) best = group[i];
    }
    return best.p;
  });

  return kept;
}
