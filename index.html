<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Road-Aware Isochrone Calculator</title>
  <meta name="description" content="Calculate accurate travel time boundaries following actual roads. Free, open-source tool using Google Maps API.">
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    :root{
      --brand: #2563eb; --brand2:#059669; --ink:#111827; --muted:#6b7280; --card:#ffffff; --bg:#f3f4f6;
      --ok:#10b981; --warn:#f59e0b; --err:#ef4444; --violet:#7c3aed;
    }
    body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,sans-serif;background:var(--bg);padding:20px;color:var(--ink)}
    .container{max-width:1280px;margin:0 auto}
    .card{background:var(--card);border-radius:14px;box-shadow:0 6px 18px rgba(0,0,0,.06);padding:22px;margin-bottom:16px}
    .header{background:linear-gradient(100deg,var(--brand2),var(--brand));color:#fff;border-radius:16px;padding:28px;margin-bottom:16px}
    .header h1{font-size:30px;font-weight:800;margin-bottom:6px}
    .sub{opacity:.9}
    .warning-box{background:#fef3c7;border:1px solid #fbbf24;border-radius:12px;padding:14px;display:flex;gap:12px;align-items:flex-start;margin-bottom:16px}
    .warning-icon{font-size:20px;color:#b45309}
    .form-group{margin-bottom:14px}
    .form-label{display:block;font-size:14px;font-weight:600;color:#374151;margin-bottom:8px}
    .input-group{display:flex;gap:8px}
    .form-input{width:100%;padding:10px 12px;border:1px solid #d1d5db;border-radius:10px;font-size:14px;transition:.2s}
    .form-input:focus{outline:none;border-color:var(--brand);box-shadow:0 0 0 4px rgba(37,99,235,.12)}
    .btn{padding:10px 14px;background:var(--brand);color:#fff;border:none;border-radius:10px;font-size:14px;font-weight:600;cursor:pointer;transition:.2s;display:inline-flex;align-items:center;gap:8px}
    .btn:hover:not(:disabled){filter:brightness(0.95)}
    .btn-secondary{background:#6b7280}
    .btn-ghost{background:#fff;color:var(--brand);border:1px solid #dbeafe}
    .btn-primary{background:linear-gradient(100deg,var(--brand2),var(--brand));width:100%;padding:14px;font-size:16px;border-radius:12px}
    .error-box{background:#fef2f2;border:1px solid #fecaca;border-radius:12px;padding:14px;display:flex;gap:12px;margin-bottom:16px}
    .error-icon{color:#dc2626;font-size:20px}
    .log-container{background:#0b1220;border-radius:14px;padding:16px}
    .log-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .log-title{color:#e5e7eb;font-weight:600}
    .log-content{background:#030712;border-radius:10px;padding:12px;height:200px;overflow-y:auto;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px}
    .log-entry{margin-bottom:4px}
    .log-entry.error{color:#f87171}.log-entry.warning{color:#fbbf24}.log-entry.success{color:#34d399}.log-entry.info{color:#d1d5db}
    .log-timestamp{color:#6b7280}
    .stats-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:16px;text-align:center}
    .stat-value{font-size:24px;font-weight:800;margin-bottom:4px}
    .stat-label{font-size:13px;color:#6b7280}
    #map{width:100%;height:72vh;border-radius:14px;background:#eef2ff;border:1px solid #e5e7eb}
    .map-toolbar{display:flex;gap:8px;margin-bottom:12px}
    .info-box{background:#e8f1ff;border-radius:14px;padding:22px}
    .info-title{font-weight:700;color:#1e3a8a;margin-bottom:10px}
    .location-info{margin-top:4px;font-size:12px;color:#6b7280}
    .spinner{display:inline-block;width:20px;height:20px;border:3px solid rgba(255,255,255,.35);border-radius:50%;border-top-color:#fff;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .hidden{display:none}
    .footer{color:#6b7280;font-size:14px;text-align:center;padding:20px}
    /* Sticky usage bar */
    .usagebar{position:sticky;bottom:0;margin-top:18px;background:#0b1220;color:#e5e7eb;border-radius:12px;padding:10px 14px;display:flex;justify-content:space-between;align-items:center;box-shadow:0 -6px 16px rgba(0,0,0,.08)}
    .usagebar small{color:#93a3b8}
    @media (max-width:640px){.stats-grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <h1>üõ£Ô∏è Road-Aware Isochrone Calculator</h1>
      <p class="sub">Follow actual roads to find your true travel boundary</p>
    </div>

    <!-- API Key notice -->
    <div class="warning-box">
      <span class="warning-icon">‚ö†Ô∏è</span>
      <div>
        <div style="font-weight:700;color:#92400e;margin-bottom:4px">Important: API Key Required</div>
        <div style="font-size:14px;color:#92400e;line-height:1.5">
          This tool needs a Google Maps API key with <b>Directions (or Routes)</b> and <b>Places</b> enabled.
          Keep your key private and restrict it.
          <a href="https://developers.google.com/maps/documentation/javascript/get-api-key" target="_blank" style="color:#2563eb;text-decoration:underline">How to get a key ‚Üí</a>
        </div>
      </div>
    </div>

    <!-- API Key -->
    <div class="card">
      <div class="form-group">
        <label class="form-label">Google Maps API Key</label>
        <div class="input-group">
          <input type="password" id="apiKey" class="form-input" placeholder="Enter your API key‚Ä¶">
          <button id="toggleApiKey" class="btn btn-secondary" type="button">üëÅÔ∏è</button>
          <button id="saveApiKey" class="btn" type="button">Save Locally</button>
        </div>
        <div class="location-info">
          Stored locally in your browser. Est. per-call cost uses $0.005 by default (see pricing note below).
        </div>
      </div>
    </div>

    <!-- Error -->
    <div id="errorBox" class="error-box hidden">
      <span class="error-icon">‚ö†Ô∏è</span>
      <div>
        <div style="font-weight:600;color:#991b1b;margin-bottom:4px">Error</div>
        <div id="errorMessage" style="font-size:14px;color:#b91c1c"></div>
      </div>
    </div>

    <!-- Controls -->
    <div class="card">
      <!-- Location Search with Autocomplete -->
      <div class="form-group">
        <label class="form-label">Starting Location</label>
        <div class="input-group">
          <input id="searchAddress" class="form-input" type="text" placeholder="Start typing an address or place‚Ä¶" value="London, UK">
          <button id="searchBtn" class="btn btn-ghost" type="button">üìç Find</button>
        </div>
        <div id="locationInfo" class="location-info">Current: (51.5074, -0.1278)</div>
      </div>

      <!-- Only Road-Aware (radial removed) -->
      <div class="form-group" style="margin-top:8px">
        <label class="form-label">Time Limit: <span id="timeLimitValue">15</span> minutes</label>
        <input id="timeLimit" class="form-input" type="range" min="5" max="60" value="15" />
      </div>

      <button id="calculateBtn" class="btn btn-primary" type="button">
        <span id="calculateBtnContent">‚ö° Calculate 15-Minute Road Isochrone</span>
      </button>
    </div>

    <!-- Logs -->
    <div class="card log-container">
      <div class="log-header">
        <div class="log-title">‚ÑπÔ∏è Activity Log</div>
        <button id="clearLogsBtn" class="btn btn-ghost" type="button">Clear</button>
      </div>
      <div id="logContent" class="log-content">
        <div style="color:#6b7280">Waiting for API key‚Ä¶</div>
      </div>
    </div>

    <!-- Stats -->
    <div id="statsCard" class="card hidden">
      <h3 style="font-weight:700;margin-bottom:12px">Results Summary</h3>
      <div class="stats-grid">
        <div><div id="apiCallsStat" class="stat-value" style="color:#2563eb">0</div><div class="stat-label">API Calls</div></div>
        <div><div id="pointsStat" class="stat-value" style="color:#059669">0</div><div class="stat-label">Points Found</div></div>
        <div>
          <div id="costStat" class="stat-value" style="color:var(--violet)">$0.000</div>
          <div class="stat-label">Est. Cost ‚Äî <span style="font-weight:600">before or after free tier</span></div>
        </div>
        <div><div id="completeStat" class="stat-value" style="color:#ea580c">‚Äî</div><div class="stat-label">Complete</div></div>
      </div>
    </div>

    <!-- Map -->
    <div class="card">
      <div class="map-toolbar">
        <button id="fullscreenBtn" class="btn btn-ghost" type="button">‚§¢ Fullscreen</button>
        <button id="resetViewBtn" class="btn btn-ghost" type="button">üîÑ Reset View</button>
      </div>
      <div id="map"></div>
    </div>

    <!-- Info -->
    <div class="info-box">
      <h3 class="info-title">üõ£Ô∏è How This Works</h3>
      <div style="font-size:14px;color:#1e40af;line-height:1.6">
        <p>‚Ä¢ Tests actual driving routes to multiple destinations</p>
        <p>‚Ä¢ Follows real roads including motorways and A-roads</p>
        <p>‚Ä¢ Calculates the exact boundary by travel time</p>
        <p>‚Ä¢ Builds an isochrone polygon that respects the network</p>
        <p>‚Ä¢ Uses Google <b>Directions</b> (legacy) via Maps JS; pricing similar to the newer <b>Routes API</b></p>
      </div>
    </div>

    <!-- Footer -->
    <div class="footer">
      <p>
        Open Source Tool |
        <a href="https://github.com/yourusername/road-isochrone" target="_blank">View on GitHub</a> |
        <a href="https://github.com/yourusername/road-isochrone/issues" target="_blank">Report Issues</a>
      </p>
      <p style="margin-top:8px">Made with ‚ù§Ô∏è for accurate travel planning</p>
    </div>

    <!-- Usage Bar -->
    <div class="usagebar" id="usageBar">
      <div>API Calls: <b id="usageCalls">0</b> ‚Ä¢ Points: <b id="usagePoints">0</b></div>
      <div>Est. Cost: <b id="usageCost">$0.000</b> <small>(before or after free tier)</small></div>
    </div>
  </div>

  <script>
    // -------- State --------
    const state = {
      apiKey: '',
      mosqueLocation: { lat: 51.5074, lng: -0.1278 },
      searchAddress: 'London, UK',
      isCalculating: false,
      logs: [],
      error: '',
      apiCalls: 0,
      boundaries: [],
      timeLimit: 15,
      // Removed user control; 100√ó old 200 max = 20,000
      maxApiCalls: 100,
      map: null,
      markers: [],
      polygon: null,
      paths: [],
      directionsService: null,
      placesService: null,
      startingPointMarker: null,
      autocomplete: null,
      sessionToken: null, // for Autocomplete (New) semantics
      estCostPerCall: 0.005 // default; see pricing notes
    };

    // -------- DOM --------
    const el = {
      apiKey: document.getElementById('apiKey'),
      toggleApiKey: document.getElementById('toggleApiKey'),
      saveApiKey: document.getElementById('saveApiKey'),
      searchAddress: document.getElementById('searchAddress'),
      searchBtn: document.getElementById('searchBtn'),
      calculateBtn: document.getElementById('calculateBtn'),
      logContent: document.getElementById('logContent'),
      clearLogsBtn: document.getElementById('clearLogsBtn'),
      errorBox: document.getElementById('errorBox'),
      errorMessage: document.getElementById('errorMessage'),
      locationInfo: document.getElementById('locationInfo'),
      timeLimit: document.getElementById('timeLimit'),
      timeLimitValue: document.getElementById('timeLimitValue'),
      statsCard: document.getElementById('statsCard'),
      apiCallsStat: document.getElementById('apiCallsStat'),
      pointsStat: document.getElementById('pointsStat'),
      costStat: document.getElementById('costStat'),
      completeStat: document.getElementById('completeStat'),
      calculateBtnContent: document.getElementById('calculateBtnContent'),
      usageBar: document.getElementById('usageBar'),
      usageCalls: document.getElementById('usageCalls'),
      usagePoints: document.getElementById('usagePoints'),
      usageCost: document.getElementById('usageCost'),
      fullscreenBtn: document.getElementById('fullscreenBtn'),
      resetViewBtn: document.getElementById('resetViewBtn'),
      mapDiv: document.getElementById('map')
    };

    // Load saved key
    const savedApiKey = localStorage.getItem('gmaps_api_key');
    if (savedApiKey) {
      state.apiKey = savedApiKey;
      el.apiKey.value = savedApiKey;
      addLog('API key loaded from local storage','success');
      loadGoogleMaps();
    }

    // -------- Utils --------
    function addLog(message, type='info'){
      const timestamp = new Date().toLocaleTimeString();
      state.logs.push({message, type, timestamp});
      console.log(`[${type}] ${message}`);
      renderLogs();
    }
    function renderLogs(){
      if(!state.logs.length){
        el.logContent.innerHTML = '<div style="color:#6b7280">Waiting for API key‚Ä¶</div>'; return;
      }
      el.logContent.innerHTML = state.logs.map(l =>
        `<div class="log-entry ${l.type}"><span class="log-timestamp">[${l.timestamp}]</span> ${l.message}</div>`
      ).join('');
      el.logContent.scrollTop = el.logContent.scrollHeight;
    }
    function setError(msg){
      state.error = msg || '';
      if(msg){ el.errorMessage.textContent = msg; el.errorBox.classList.remove('hidden'); }
      else { el.errorBox.classList.add('hidden'); }
    }
    function updateLocationInfo(){
      el.locationInfo.textContent = `Current: (${state.mosqueLocation.lat.toFixed(4)}, ${state.mosqueLocation.lng.toFixed(4)})`;
    }
    function updateStats(){
      const cost = state.apiCalls * state.estCostPerCall;
      if (state.apiCalls > 0 || state.boundaries.length > 0) {
        el.statsCard.classList.remove('hidden');
        el.apiCallsStat.textContent = state.apiCalls;
        el.pointsStat.textContent = state.boundaries.length;
        el.costStat.textContent = `$${cost.toFixed(3)}`;
        el.completeStat.textContent = state.boundaries.length ? '‚úì' : '‚Äî';
      } else {
        el.statsCard.classList.add('hidden');
      }
      el.usageCalls.textContent = state.apiCalls;
      el.usagePoints.textContent = state.boundaries.length;
      el.usageCost.textContent = `$${cost.toFixed(3)}`;
    }
    function clearStartingPointMarker(){
      if(state.startingPointMarker){ state.startingPointMarker.setMap(null); state.startingPointMarker=null; }
    }

    // -------- Google Maps --------
    function loadGoogleMaps(){
      if (!state.apiKey){ addLog('Please enter your Google Maps API key','warning'); return; }
      if (window.google && window.google.maps){ addLog('Google Maps already loaded','success'); initializeMap(); return; }
      addLog('Loading Google Maps script‚Ä¶');
      const s = document.createElement('script');
      s.src = `https://maps.googleapis.com/maps/api/js?key=${state.apiKey}&libraries=geometry,places`;
      s.async = true;
      s.onload = () => { addLog('Google Maps loaded successfully','success'); initializeMap(); };
      s.onerror = () => { setError('Failed to load Google Maps. Check your API key and enabled APIs.'); addLog('Failed to load Google Maps','error'); };
      document.body.appendChild(s);
    }

    function initializeMap(){
      if (state.map) return;
      try{
        state.map = new google.maps.Map(el.mapDiv,{
          center: state.mosqueLocation,
          zoom: 11,
          fullscreenControl: true,
          streetViewControl: false,
          mapTypeControl: false,
          styles: [
            {featureType:'poi',stylers:[{visibility:'off'}]},
            {featureType:'transit',stylers:[{visibility:'off'}]}
          ]
        });
        state.directionsService = new google.maps.DirectionsService();
        state.placesService = new google.maps.places.PlacesService(state.map);

        // Autocomplete (New) on the search input
        state.sessionToken = new google.maps.places.AutocompleteSessionToken();
        state.autocomplete = new google.maps.places.Autocomplete(el.searchAddress, {
          fields: ['geometry','name','formatted_address'],
          types: ['geocode']
        });
        state.autocomplete.setOptions({ sessionToken: state.sessionToken });
        state.autocomplete.addListener('place_changed', () => {
          const place = state.autocomplete.getPlace();
          if (!place.geometry || !place.geometry.location) return;
          const loc = { lat: place.geometry.location.lat(), lng: place.geometry.location.lng() };
          state.mosqueLocation = loc;
          updateLocationInfo();
          addLog(`üìç ${place.formatted_address || place.name}`,'success');
          if (state.map){
            state.map.setCenter(loc); state.map.setZoom(12);
            clearVisualization(); clearStartingPointMarker();
            state.startingPointMarker = new google.maps.Marker({
              position: loc, map: state.map, title:'Starting Point',
              icon:{path:google.maps.SymbolPath.CIRCLE,scale:10,fillColor:'#ef4444',fillOpacity:1,strokeColor:'#fff',strokeWeight:2}
            });
          }
          // new session token for the next search session
          state.sessionToken = new google.maps.places.AutocompleteSessionToken();
          state.autocomplete.setOptions({ sessionToken: state.sessionToken });
        });

        // Initial marker
        state.startingPointMarker = new google.maps.Marker({
          position: state.mosqueLocation, map: state.map, title:'Starting Point',
          icon:{path:google.maps.SymbolPath.CIRCLE,scale:10,fillColor:'#ef4444',fillOpacity:1,strokeColor:'#fff',strokeWeight:2}
        });

        addLog('Map initialized','success');
      }catch(err){
        addLog(`Map init error: ${err.message}`,'error');
        setError('Failed to initialize map');
      }
    }

    function clearVisualization(){
      state.markers.forEach(m=>m.setMap(null)); state.markers=[];
      state.paths.forEach(p=>p.setMap(null)); state.paths=[];
      if (state.polygon){ state.polygon.setMap(null); state.polygon=null; }
    }

    function calculateDestinationPoint(origin, bearing, distanceKm){
      const R=6371, lat1=origin.lat*Math.PI/180, lng1=origin.lng*Math.PI/180, br=bearing*Math.PI/180, d=distanceKm/R;
      const lat2 = Math.asin(Math.sin(lat1)*Math.cos(d)+Math.cos(lat1)*Math.sin(d)*Math.cos(br));
      const lng2 = lng1 + Math.atan2(Math.sin(br)*Math.sin(d)*Math.cos(lat1), Math.cos(d)-Math.sin(lat1)*Math.sin(lat2));
      return { lat:lat2*180/Math.PI, lng:lng2*180/Math.PI };
    }

    async function findMajorDestinations(center){
      addLog('üîç Generating test destinations‚Ä¶');
      const dests=[]; const distances=[10,20,30,40]; // km buckets
      const angles=[0,30,60,90,120,150,180,210,240,270,300,330];
      angles.forEach(a=>distances.forEach(km=>dests.push({location:calculateDestinationPoint(center,a,km),name:`${a}¬∞ @ ${km}km`})));
      addLog(`üìç Generated ${dests.length} destinations`,'success');
      return dests;
    }

    async function testRouteToDestination(origin, destination){
      try{
        const req = {
          origin, destination: destination.location, travelMode: google.maps.TravelMode.DRIVING,
          unitSystem: google.maps.UnitSystem.METRIC, avoidHighways:false, avoidTolls:false, provideRouteAlternatives:true
        };
        const result = await new Promise((res,rej)=>{
          state.directionsService.route(req,(r,status)=>{
            if(status==='OK') res(r); else if(status==='ZERO_RESULTS') res(null); else rej(new Error(`API: ${status}`));
          });
        });
        state.apiCalls++; updateStats();

        if (!result || !result.routes?.length) return null;

        const boundaries=[];
        for (const route of result.routes){
          let totalMin=0, boundaryPoint=null; const pathPts=[];
          for (const leg of route.legs){
            for (const step of leg.steps){
              const stepMin = step.duration.value/60;
              if (totalMin + stepMin <= state.timeLimit){
                totalMin += stepMin; if (step.path) pathPts.push(...step.path);
              } else {
                const remaining = state.timeLimit - totalMin;
                const frac = Math.max(0, Math.min(1, remaining/stepMin));
                if (step.path && step.path.length>1){
                  const totalDist = google.maps.geometry.spherical.computeLength(step.path);
                  const target = totalDist * frac; let acc=0;
                  for (let i=0;i<step.path.length-1;i++){
                    const seg = google.maps.geometry.spherical.computeDistanceBetween(step.path[i], step.path[i+1]);
                    if (acc + seg >= target){
                      const segFrac = (target - acc) / seg;
                      boundaryPoint = {
                        lat: step.path[i].lat() + (step.path[i+1].lat() - step.path[i].lat())*segFrac,
                        lng: step.path[i].lng() + (step.path[i+1].lng() - step.path[i].lng())*segFrac
                      };
                      break;
                    }
                    acc += seg;
                  }
                } else {
                  const s=step.start_location,e=step.end_location;
                  boundaryPoint = { lat: s.lat()+(e.lat()-s.lat())*frac, lng: s.lng()+(e.lng()-s.lng())*frac };
                }
                break;
              }
            }
            if (boundaryPoint) break;
          }
          if (boundaryPoint){
            if (pathPts.length && state.map){
              const path = new google.maps.Polyline({
                path: pathPts, geodesic:true, strokeColor:'#3b82f6', strokeOpacity:.3, strokeWeight:2, map:state.map
              });
              state.paths.push(path);
            }
            boundaries.push(boundaryPoint);
          }
        }
        if (!boundaries.length) return null;
        boundaries.sort((a,b)=>{
          const da=Math.hypot(a.lat-origin.lat, a.lng-origin.lng);
          const db=Math.hypot(b.lat-origin.lat, b.lng-origin.lng);
          return db-da;
        });
        return boundaries[0];
      }catch{ return null; }
    }

    async function fillGapsInBoundary(boundaryPoints){
      const out=[]; const c=state.mosqueLocation;
      const sorted=[...boundaryPoints].sort((a,b)=>{
        const A=Math.atan2(a.lng-c.lng, a.lat-c.lat); const B=Math.atan2(b.lng-c.lng, b.lat-c.lat); return A-B;
      });
      for(let i=0;i<sorted.length;i++){
        const j=(i+1)%sorted.length, p1=sorted[i], p2=sorted[j];
        let a1=Math.atan2(p1.lng-c.lng, p1.lat-c.lat)*180/Math.PI;
        let a2=Math.atan2(p2.lng-c.lng, p2.lat-c.lat)*180/Math.PI;
        let diff=a2-a1; if(diff<0) diff+=360;
        if (diff>30 && state.apiCalls<state.maxApiCalls){
          const mid=(a1+diff/2)%360;
          const test=calculateDestinationPoint(c, mid, 25);
          const r=await testRouteToDestination(c,{location:test,name:`Gap @ ${mid.toFixed(0)}¬∞`});
          if (r) out.push(r);
        }
      }
      return out;
    }

    function visualizeResults(points){
      if(!state.map) return;
      addLog(`üé® Drawing ${points.length} boundary points`);
      if(!state.startingPointMarker){
        state.startingPointMarker = new google.maps.Marker({
          position: state.mosqueLocation, map: state.map, title:'Starting Point',
          icon:{path:google.maps.SymbolPath.CIRCLE,scale:10,fillColor:'#ef4444',fillOpacity:1,strokeColor:'#fff',strokeWeight:2}
        });
      }
      points.forEach((p,i)=>{
        const m=new google.maps.Marker({
          position:p,map:state.map,title:`Boundary ${i+1}`,
          icon:{path:google.maps.SymbolPath.CIRCLE,scale:5,fillColor:'#10b981',fillOpacity:.85,strokeColor:'#fff',strokeWeight:1.5}
        });
        state.markers.push(m);
      });
      if(points.length>=3){
        const c=state.mosqueLocation;
        const sorted=[...points].sort((a,b)=>{
          const A=Math.atan2(a.lng-c.lng, a.lat-c.lat); const B=Math.atan2(b.lng-c.lng, b.lat-c.lat); return A-B;
        });
        state.polygon = new google.maps.Polygon({
          paths: sorted, strokeColor:'#10b981', strokeOpacity:.9, strokeWeight:2, fillColor:'#10b981', fillOpacity:.15, map:state.map
        });
        const bounds=new google.maps.LatLngBounds();
        sorted.forEach(pt=>bounds.extend(pt)); bounds.extend(c);
        state.map.fitBounds(bounds);
        const area = google.maps.geometry.spherical.computeArea(sorted)/1e6;
        addLog(`üìê Polygon area: ${area.toFixed(2)} km¬≤`,'success');
        addLog('‚ú® Visualization complete!','success');
      }
    }

    async function calculateRoadAwareIsochrone(){
      if(!state.apiKey){ setError('Please enter your Google Maps API key first'); return; }
      state.isCalculating = true; setError(''); state.logs=[]; state.apiCalls=0; state.boundaries=[]; clearVisualization(); updateStats();
      addLog(`üöÄ Starting ROAD-AWARE calculation for ${state.timeLimit} minutes`);
      el.calculateBtn.disabled = true;
      el.calculateBtnContent.innerHTML = `<span class="spinner"></span> Exploring roads‚Ä¶ (Calls: <span id="apiCallsCount">0</span>)`;

      if(!state.directionsService){ setError('Google Maps not initialized properly.'); endCalc(); return; }

      try{
        const dests = await findMajorDestinations(state.mosqueLocation);
        addLog(`üìç Testing up to ${Math.min(dests.length, state.maxApiCalls)} destinations`);
        const pts=[];
        const batch=8;
        for(let i=0;i<Math.min(dests.length, state.maxApiCalls); i+=batch){
          const slice=dests.slice(i,i+batch);
          const results = await Promise.allSettled(slice.map(d=>testRouteToDestination(state.mosqueLocation,d)));
          results.forEach(r=>{ if(r.status==='fulfilled' && r.value) pts.push(r.value); });
          const c=document.getElementById('apiCallsCount'); if(c) c.textContent = state.apiCalls;
          if(i+batch<dests.length) await new Promise(r=>setTimeout(r,180));
        }
        addLog(`‚úÖ Found ${pts.length} boundary points along roads`,'success');

        if(pts.length>=3){
          addLog('üìç Filling gaps between points‚Ä¶');
          const extra = await fillGapsInBoundary(pts); pts.push(...extra);
        }
        if(pts.length){ state.boundaries=pts; visualizeResults(pts); updateStats(); }
        else setError('No boundary points found. Try adjusting the time limit or check API permissions.');

      }catch(err){ addLog(`‚ùå Critical error: ${err.message}`,'error'); setError(err.message); }
      finally{ endCalc(); }
    }
    function endCalc(){
      state.isCalculating=false; el.calculateBtn.disabled=false;
      el.calculateBtnContent.innerHTML = `‚ö° Calculate ${state.timeLimit}-Minute Road Isochrone`;
    }

    // Geocode fallback for manual search button
    async function searchForAddress(){
      if(!state.searchAddress || !window.google){ setError('Please enter an address and ensure Google Maps is loaded'); return; }
      addLog(`üîç Searching for: ${state.searchAddress}`);
      const geocoder = new google.maps.Geocoder();
      geocoder.geocode({address: state.searchAddress},(results,status)=>{
        if(status==='OK' && results[0]){
          const loc = { lat: results[0].geometry.location.lat(), lng: results[0].geometry.location.lng() };
          state.mosqueLocation=loc; updateLocationInfo(); addLog(`üìç ${results[0].formatted_address}`,'success');
          if(state.map){
            state.map.setCenter(loc); state.map.setZoom(12);
            clearVisualization(); clearStartingPointMarker();
            state.startingPointMarker = new google.maps.Marker({
              position:loc,map:state.map,title:'Starting Point',
              icon:{path:google.maps.SymbolPath.CIRCLE,scale:10,fillColor:'#ef4444',fillOpacity:1,strokeColor:'#fff',strokeWeight:2}
            });
          }
        } else { addLog(`‚ùå Geocoding failed: ${status}`,'error'); setError('Could not find location. Try a different address.'); }
      });
    }

    // -------- Events --------
    el.toggleApiKey.addEventListener('click', ()=>{
      el.apiKey.type = el.apiKey.type==='password' ? 'text' : 'password';
      el.toggleApiKey.textContent = el.apiKey.type==='password' ? 'üëÅÔ∏è' : 'üôà';
    });
    el.saveApiKey.addEventListener('click', ()=>{
      const key = el.apiKey.value.trim();
      if(key){ localStorage.setItem('gmaps_api_key',key); state.apiKey=key; addLog('API key saved to local storage','success'); loadGoogleMaps(); }
      else setError('Please enter a valid API key');
    });
    el.apiKey.addEventListener('change', e=>{ state.apiKey=e.target.value; if(state.apiKey) loadGoogleMaps(); });

    el.searchAddress.addEventListener('input', e=>{ state.searchAddress = e.target.value; });
    el.searchAddress.addEventListener('keypress', e=>{ if(e.key==='Enter') searchForAddress(); });
    el.searchBtn.addEventListener('click', searchForAddress);

    el.timeLimit.addEventListener('input', e=>{
      state.timeLimit = Number(e.target.value);
      el.timeLimitValue.textContent = state.timeLimit;
      el.calculateBtnContent.innerHTML = `‚ö° Calculate ${state.timeLimit}-Minute Road Isochrone`;
    });

    el.clearLogsBtn.addEventListener('click', ()=>{ state.logs=[]; renderLogs(); });

    el.calculateBtn.addEventListener('click', ()=>{
      if(!state.apiKey){ setError('Please enter your Google Maps API key first'); return; }
      calculateRoadAwareIsochrone();
    });

    el.fullscreenBtn.addEventListener('click', ()=>{
      const card = el.mapDiv.parentElement; // card containing map
      if (!document.fullscreenElement){ (card.requestFullscreen ? card.requestFullscreen() : el.mapDiv.requestFullscreen?.()); }
      else { document.exitFullscreen?.(); }
    });
    el.resetViewBtn.addEventListener('click', ()=>{
      if(state.map){ state.map.setCenter(state.mosqueLocation); state.map.setZoom(11); }
    });

    // Init
    updateLocationInfo(); updateStats();

  </script>
</body>
</html>
